---
layout: post
title: "Recursion in Scala"
published: false
tags: [scala, recursion]
---

## Recursion

递归三要素:

    1. 初始值
    2. 递归公式
    3. 终止条件

其中终止条件多数时候是比较明确的，　比如求解 `ｆ(n)` 的问题, 终止条件就是`n`. 

算法面试题中一大半可以使用递归来解决, 比如扔鸡蛋问题, 爬楼梯问题等等. 这种问题有一个典型特征,非常明显, 即可以简化成:

> 求解`f(n)` 

有时候会故意加难, 变成2维 `f(nx, ny)` 3维甚至多维的问题.

这种问题的求解思路其实很简单. 有时找到实际的求解算法比较难,是因为将实际问题建模成递归问题时,三要素本身难以简单找到, 比如有时初始值不确定, 有时递归公式难以推导, 有时是终止条件不明确. 不管怎样, 寻找解的思路正确是首要的. 

某些具体问题, 在采用递归时,需要考虑中间的优化, 这就是动态规划(Dynamic Programming) 中用到的技巧. 记住了, 也是比较容易随机应变的. 

### 案例
楼梯问题:

> 有一100阶层的楼梯，有三种走楼梯方式，一次走一阶，一次走两阶，一次走三阶。用算法实现，走完100阶总共有多少种走法 

* 分析
这是典型的　求`f(n)` 的问题，　并且　终止条件　非常明确，　即　`n=100`，　需要寻找初始值和递归条件

* 初始值
人肉看下 当`n=0,1,2,3 ` 时 `f(0)` 的值

| n  | f(n) |
| ------------- | ------------- |
| 0  | 1  |
| 1  | 1  |
| 2  | 2  |
| 3  | 4  |

* 递归公式
寻找递归公式是比较难的过程, 和具体问题相关,有时候需要变换各种角度来看问题. 
这个问题是相对简单的. 假设我们知道了`f(n)`, 如何求`f(n+1)`呢?
可以变换个思路, 当我们需要爬到`n+1`层时, 可以考虑最后一步的走法, 有三种可能, 分别是最后一步走:

    * 1 个台阶, 上一步走到`ｎ`层
    * 2 个台阶, 上一步走到`ｎ-1`层
    * 3 个台阶, 上一步走到`ｎ-2`层

这三种情况是互斥的,　并且包含了所有的可能, 从而, 我们有:
    
    ```
    f(n+1) = f(n) + f(n-1) + f(n-2)
    ```


* 终止条件
* 
* 


## 尾递归(tail-recursion)

### 尾递归和函数式编程
#### 闭包
尾递归


