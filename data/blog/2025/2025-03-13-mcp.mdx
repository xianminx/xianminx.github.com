---
title: 'Model Context Protocol (MCP)'
date: '2025-03-13'
summary: 'The Model Context Protocol (MCP) is a protocol for building and deploying AI agents that are able to understand and interact with the context in which they are operating.'
tags: ['AI', 'mcp', 'agent']
authors: ['Lucas']
image: '/imgs/blog/2025/mcp.png'
---

MCP åè®®æä¾› stdio IPC å’Œ SSE ä¸¤ç§ä¼ è¾“æ–¹å¼ã€‚

æ ¸å¿ƒæä¾›ä¸¤ä¸ª JSON rpc å‡½æ•°:

- listTools
- callTool

* Resource
* tools
* Prompts: more like a tempalted string prompt, but leave it to the server to decide how to use it.

why separate resource from tools?

In general, resource and tools different like http verb semantics. Resource is more like a static content, while tool is more like a function call.

These 3 components are common in a comman LLM applicaiton, and sicne when we develop LLM applicaitons, we spend most of the time tuning these components, it is important to have a standard way to specify them.

so MCP abstract these components and provide a interface for developers to customize them.

This is typical LLM centeric perspective, but it is not the only perspective.

Background

LLM can generate function call, but it is not enough.

You as a developer, need to tell LLM the specification of the functions available. .

Then you decide how to interpret the function call, and how to implement the function.

So it is ad-hoc and not scalable.

There is need to have a standard way to specify the function call and the function implementation.

Here comes MCP.

MCP is like USB for computer.

Since for general agent, it is not possible to know the function call in advance.  
We need a way for agent to discover the externl pools of tools.
The agent can utilize a way to find if there are appropriate tools for the task.
and then the agent knows hwo to call the tools by following a standard protocol.

Knowing this, the agent will be able to use a lot of tools.

## Introduction

## Hello World

This hello world project wraps Flomoapp API in a MCP server.
See [mcp-server-flomo](https://github.com/camel-ai/mcp-hello-world) for more details.

## Specification

Client
Server

service discovery

service call

Authentication

### Prompts

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: prompts/list
    Server-->>Client: List of prompts

    Note over Client,Server: Usage
    Client->>Server: prompts/get
    Server-->>Client: Prompt content

    Note over Client,Server: Changes
    opt listChanged
        Server-->>Client: prompts/list_changed
        Client->>Server: prompts/list
        Server-->>Client: Updated prompts
    end
```

- `prompts/list`
- `prompts/get`
- `prompts/list_changed`

it seems `prompts/list_changed` is not as useful as the other two. Implementations of the protocol may do not know when to nofity the client.

since the change can happen at any time, it is not possible to know when to notify the client.

## Popular libraries

- MCP client for browser use
- MCP client for code sandbox
- MCP client for mobile use
- MCP client for server use
- MCP client for Desktop use

## MCP in the wild

MCP for 3D Blender

[ğŸ¦‰ OWL: Optimized Workforce Learning for General Multi-Agent Assistance in Real-World Task Automation](https://github.com/camel-ai/owl)
ğŸ¦‰ OWL: Optimized Workforce Learning for General Multi-Agent Assistance in Real-World Task Automation

MCP as a high level protocol, should not care about the underlying transport layer.
From this perspective, the design of MCP is very cubersome.

As a high level protocol, MCP should support streaming transport and bi-directional streaming. So there is no need to care about request/response or uni-directional notification.

What is JSON-RPC? how it related to HTTP or TCP?

https://glama.ai/chat

MCP è²Œä¼¼å°±æ˜¯ tools çš„ä¸€ä¸ªåŒ…è£…ï¼Œ æ‰€ä»¥ MCP çš„ä»·å€¼æ˜¯ä»€ä¹ˆ

åŸºæœ¬æµç¨‹ï¼Œ

1. åœ¨ client ç«¯é…ç½®å¥½ MCP server çš„åœ°å€ï¼ˆæˆ–è€…python/js çš„è„šæ­¥ï¼‰
2. client è°ƒç”¨ mcp listTools è·å–å¯¹åº” server çš„å·¥å…·åˆ—è¡¨
3. client åœ¨è°ƒç”¨LLM æ—¶ï¼Œ å°†å¯¹åº” tools çš„æè¿°ä½œä¸º prompt çš„ä¸€éƒ¨åˆ†å‘é€ç»™ LLM
4. LLM åœ¨ç”Ÿæˆ response æ—¶ï¼Œ æ ¹æ® response çš„æ ¼å¼ï¼Œ è°ƒç”¨å¯¹åº”çš„å·¥å…·
5. client æ£€æŸ¥ LLM çš„ responseï¼Œ å®Œæˆtool call çš„è°ƒç”¨
6. å°† tool call çš„æ‰§è¡Œç»“æœè¿”å›ç»™ LLM
7. LLM æ ¹æ® tool call çš„æ‰§è¡Œç»“æœï¼Œ ç”Ÿæˆæœ€ç»ˆçš„ response

ä»è¿™ä¸ªæµç¨‹æ¥çœ‹ï¼Œ MCP å°±æ˜¯å°è£…äº†äº† list tools çš„æµç¨‹ï¼Œ å¯¹äºæœåŠ¡æä¾›å•†æ¥è¯´ï¼Œ å®ç° MCP çš„ä¸€ä¸ª list tools å·¥å…·ï¼Œ è€Œå…·ä½“çš„å·¥å…·è°ƒç”¨ï¼Œå¯ä»¥åŸºäº IPC æˆ–è€… HTTP Rest API æ¥å®ç°ã€‚

éè¯´ä»·å€¼ï¼Œ æ›´å¤šæ˜¯ä½¿ç”¨æ–¹ä¾¿ï¼Œ å› ä¸ºè¿™æ ·å¾ˆå¤šèŠå¤©å®¢æˆ·ç«¯å°±å¯ä»¥é€šè¿‡æ”¯æŒ MCP æ¥æ”¯æŒå„ç§å·¥å…·è°ƒç”¨ï¼Œè€Œä¸ç”¨å®¢æˆ·ç«¯å¼€å‘è€…å†…ç½®å„ç§å·¥å…·è°ƒç”¨ã€‚

å½“ç„¶ï¼Œå…¶å®å¯ä»¥å†åŠ ä¸€ä¸ªæœåŠ¡å‘ç°çš„æ¥å£ï¼Œ å°±æ˜¯å®¢æˆ·ç«¯å°†éœ€æ±‚å‘é€ç»™ MCP serverï¼Œ ç„¶å MCP server è¿”å›åˆé€‚çš„å·¥å…·åˆ—è¡¨ã€‚ï¼ˆé»˜è®¤æƒ…å†µä¸‹ï¼Œ MCP server ä¼šè¿”å›æ‰€æœ‰å·¥å…·åˆ—è¡¨ï¼‰ é«˜çº§å®ç°å¯ä»¥åŸºäº LLM æ¥å®ç°ã€‚

TODO:

- write a annotation style framework for MCP server in Typescript

for example:
This expose tools like Rest API route.

```typescript
@mcp.tool()
@mcp.stdio
@mcp.http
export function myTool(input: string) {
    return "Hello, world!";
}
```

### Node module Resolution

```mermaid
graph TD
    A[Module Specifier] --> B{Core Module?};
    B -- Yes --> C[Load Core Module];
    B -- No --> D{Relative Path?};
    D -- Yes --> E[Resolve Relative Path];
    D -- No --> F[Search node_modules];
    E --> G{Directory?};
    G -- Yes --> H[Check package.json "main"];
    H --> I[Load Entry Point];
    G -- No --> I[Load Entry Point];
    E --> J[Append Extensions (.js, .json, .node)];
    J --> I[Load Entry Point];
    F --> K{Found in node_modules?};
    K -- Yes --> L{package.json "exports" field?};
    L -- Yes --> M[Resolve using exports field];
    L-- No --> H;
    M --> I[Load Entry Point];
    K -- No --> N[Move to Parent node_modules];
    N --> F;
    I[Load Entry Point] --> O[Module Loaded];
    C --> O[Module Loaded];
```

### mcp-get

What mcp-get does is quite simple.
Whoever wants to publish a mcp-server tool to be used by Claude, can submit a PR to add the tool to the list.
For example https://github.com/michaellatman/mcp-get/pull/101/files
this PR adds a tool `mcp-server-flomo` to the package list.

On every PR, the github action will automatically bump `mcp-get` to the next version, containing the updated [package list](https://github.com/michaellatman/mcp-get/tree/main/packages).

Now, as long as the PR is merged, you can find the page at https://mcp-get.com/packages/mcp-server-flomo.
In the same time, in the terminal, you can use `npx @michaellatman/mcp-get@latest install mcp-server-flomo` to install the tool for Claude Desktop.

mcp-get is more a client side installation tool with limited registry management capabilities.

### Smithery.ai

Smithery.ai is a similar tool to mcp-get, but it can provide a cloud service to host simple mcp-server, acting like a proxy between the client and the tool provider.

For example, I deploy the `mcp-server-flomo` on Smithery.ai, and then you can find it at https://smithery.ai/server/@xianminx/mcp-server-flomo.

```json
{
  "mcpServers": {
    "mcp-server-flomo": {
      "command": "npx",
      "args": [
        "-y",
        "@smithery/cli@latest",
        "run",
        "@xianminx/mcp-server-flomo",
        "--key",
        "your-smithery-key-here"
      ]
    }
  }
}
```

This will use Smithery.ai to host the `mcp-server-flomo` and use it as a proxy server for the tool.

### composio.dev

https://mcp.composio.dev/

### Cursor

https://docs.cursor.com/context/model-context-protocol#model-context-protocol

- stdio
- sse
- tools
- resources (not supported yet)

- Architecture

- Configuration
  can be specified in the `mcp.json` file, project root or user home directory.

ä½¿ç”¨ stdio æ—¶ï¼Œ ä¸èƒ½è½»æ˜“ä½¿ç”¨ console.log æ¥è¾“å‡ºä¿¡æ¯ï¼Œ å› ä¸º stdio çš„è¾“å‡ºä¼šè¢«æˆªæ–­ã€‚

- Protocol
  - connect
  - notification
  - setRequestHandler
  - setNotificationHandler
