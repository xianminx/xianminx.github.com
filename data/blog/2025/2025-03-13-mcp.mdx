---
title: 'Model Context Protocol (MCP)'
date: '2025-03-13'
summary: 'The Model Context Protocol (MCP) is a protocol for building and deploying AI agents that are able to understand and interact with the context in which they are operating.'
tags: ['AI', 'mcp', 'agent']
authors: ['Lucas']
image: '/imgs/blog/2025/mcp.png'
---

- Resource
- tools
- Prompts: more like a tempalted string prompt, but leave it to the server to decide how to use it.

why separate resource from tools?

In general, resource and tools different like http verb semantics. Resource is more like a static content, while tool is more like a function call.

These 3 components are common in a comman LLM applicaiton, and sicne when we develop LLM applicaitons, we spend most of the time tuning these components, it is important to have a standard way to specify them.

so MCP abstract these components and provide a interface for developers to customize them.

This is typical LLM centeric perspective, but it is not the only perspective.

Background

LLM can generate function call, but it is not enough.

You as a developer, need to tell LLM the specification of the functions available. .

Then you decide how to interpret the function call, and how to implement the function.

So it is ad-hoc and not scalable.

There is need to have a standard way to specify the function call and the function implementation.

Here comes MCP.

MCP is like USB for computer.

Since for general agent, it is not possible to know the function call in advance.  
We need a way for agent to discover the externl pools of tools.
The agent can utilize a way to find if there are appropriate tools for the task.
and then the agent knows hwo to call the tools by following a standard protocol.

Knowing this, the agent will be able to use a lot of tools.

## Introduction

## Hello World

## Specification

Client
Server

service discovery

service call

Authentication

### Prompts

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: Discovery
    Client->>Server: prompts/list
    Server-->>Client: List of prompts

    Note over Client,Server: Usage
    Client->>Server: prompts/get
    Server-->>Client: Prompt content

    Note over Client,Server: Changes
    opt listChanged
        Server-->>Client: prompts/list_changed
        Client->>Server: prompts/list
        Server-->>Client: Updated prompts
    end
```

- `prompts/list`
- `prompts/get`
- `prompts/list_changed`

it seems `prompts/list_changed` is not as useful as the other two. Implementations of the protocol may do not know when to nofity the client.

since the change can happen at any time, it is not possible to know when to notify the client.

## Popular libraries

- MCP client for browser use
- MCP client for code sandbox
- MCP client for mobile use
- MCP client for server use
- MCP client for Desktop use

## MCP in the wild

MCP for 3D Blender

[ðŸ¦‰ OWL: Optimized Workforce Learning for General Multi-Agent Assistance in Real-World Task Automation](https://github.com/camel-ai/owl)
ðŸ¦‰ OWL: Optimized Workforce Learning for General Multi-Agent Assistance in Real-World Task Automation

MCP as a high level protocol, should not care about the underlying transport layer.
From this perspective, the design of MCP is very cubersome.

As a high level protocol, MCP should support streaming transport and bi-directional streaming. So there is no need to care about request/response or uni-directional notification.

What is JSON-RPC? how it related to HTTP or TCP?

https://glama.ai/chat

MCP è²Œä¼¼å°±æ˜¯ tools çš„ä¸€ä¸ªåŒ…è£…ï¼Œ æ‰€ä»¥ MCP çš„ä»·å€¼æ˜¯ä»€ä¹ˆ

åŸºæœ¬æµç¨‹ï¼Œ

1. åœ¨ client ç«¯é…ç½®å¥½ MCP server çš„åœ°å€ï¼ˆæˆ–è€…python/js çš„è„šæ­¥ï¼‰
2. client è°ƒç”¨ mcp listTools èŽ·å–å¯¹åº” server çš„å·¥å…·åˆ—è¡¨
3. client åœ¨è°ƒç”¨LLM æ—¶ï¼Œ å°†å¯¹åº” tools çš„æè¿°ä½œä¸º prompt çš„ä¸€éƒ¨åˆ†å‘é€ç»™ LLM
4. LLM åœ¨ç”Ÿæˆ response æ—¶ï¼Œ æ ¹æ® response çš„æ ¼å¼ï¼Œ è°ƒç”¨å¯¹åº”çš„å·¥å…·
5. client æ£€æŸ¥ LLM çš„ responseï¼Œ å®Œæˆtool call çš„è°ƒç”¨
6. å°† tool call çš„æ‰§è¡Œç»“æžœè¿”å›žç»™ LLM
7. LLM æ ¹æ® tool call çš„æ‰§è¡Œç»“æžœï¼Œ ç”Ÿæˆæœ€ç»ˆçš„ response

ä»Žè¿™ä¸ªæµç¨‹æ¥çœ‹ï¼Œ MCP å°±æ˜¯å°è£…äº†äº† list tools çš„æµç¨‹ï¼Œ å¯¹äºŽæœåŠ¡æä¾›å•†æ¥è¯´ï¼Œ å®žçŽ° MCP çš„ä¸€ä¸ª list tools å·¥å…·ï¼Œ è€Œå…·ä½“çš„å·¥å…·è°ƒç”¨ï¼Œå¯ä»¥åŸºäºŽ IPC æˆ–è€… HTTP Rest API æ¥å®žçŽ°ã€‚

éžè¯´ä»·å€¼ï¼Œ æ›´å¤šæ˜¯ä½¿ç”¨æ–¹ä¾¿ï¼Œ å› ä¸ºè¿™æ ·å¾ˆå¤šèŠå¤©å®¢æˆ·ç«¯å°±å¯ä»¥é€šè¿‡æ”¯æŒ MCP æ¥æ”¯æŒå„ç§å·¥å…·è°ƒç”¨ï¼Œè€Œä¸ç”¨å®¢æˆ·ç«¯å¼€å‘è€…å†…ç½®å„ç§å·¥å…·è°ƒç”¨ã€‚

å½“ç„¶ï¼Œå…¶å®žå¯ä»¥å†åŠ ä¸€ä¸ªæœåŠ¡å‘çŽ°çš„æŽ¥å£ï¼Œ å°±æ˜¯å®¢æˆ·ç«¯å°†éœ€æ±‚å‘é€ç»™ MCP serverï¼Œ ç„¶åŽ MCP server è¿”å›žåˆé€‚çš„å·¥å…·åˆ—è¡¨ã€‚ï¼ˆé»˜è®¤æƒ…å†µä¸‹ï¼Œ MCP server ä¼šè¿”å›žæ‰€æœ‰å·¥å…·åˆ—è¡¨ï¼‰ é«˜çº§å®žçŽ°å¯ä»¥åŸºäºŽ LLM æ¥å®žçŽ°ã€‚

TODO:

- write a annotation style framework for MCP server in Typescript

for example:
This expose tools like Rest API route.

```typescript
@mcp.tool()
@mcp.stdio
@mcp.http
export function myTool(input: string) {
    return "Hello, world!";
}
```

### Node module Resolution

```mermaid
graph TD
    A[Module Specifier] --> B{Core Module?};
    B -- Yes --> C[Load Core Module];
    B -- No --> D{Relative Path?};
    D -- Yes --> E[Resolve Relative Path];
    D -- No --> F[Search node_modules];
    E --> G{Directory?};
    G -- Yes --> H[Check package.json "main"];
    H --> I[Load Entry Point];
    G -- No --> I[Load Entry Point];
    E --> J[Append Extensions (.js, .json, .node)];
    J --> I[Load Entry Point];
    F --> K{Found in node_modules?};
    K -- Yes --> L{package.json "exports" field?};
    L -- Yes --> M[Resolve using exports field];
    L-- No --> H;
    M --> I[Load Entry Point];
    K -- No --> N[Move to Parent node_modules];
    N --> F;
    I[Load Entry Point] --> O[Module Loaded];
    C --> O[Module Loaded];
```
